<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ActiveParser_Must_Be_Code_Or_Markup_Parser" xml:space="preserve">
    <value>The active parser must the same as either the markup or code parser.</value>
  </data>
  <data name="Argument_Not_Valid_Class_Name" xml:space="preserve">
    <value>"{0}" is not a valid class name.</value>
  </data>
  <data name="BlockName_Code" xml:space="preserve">
    <value>code</value>
    <comment>This is a literal used when composing ParserError_* messages. Most blocks are named by the keyword that starts them, for example "if".  However, for those without keywords, a (localizable) name must be used.  This literal is ALWAYS used mid-sentence, thus should not be capitalized.</comment>
  </data>
  <data name="BlockName_ExplicitExpression" xml:space="preserve">
    <value>explicit expression</value>
    <comment>This is a literal used when composing ParserError_* messages. Most blocks are named by the keyword that starts them, for example "if".  However, for those without keywords, a (localizable) name must be used.  This literal is ALWAYS used mid-sentence, thus should not be capitalized.</comment>
  </data>
  <data name="BlockName_ImplicitExpression" xml:space="preserve">
    <value>implicit expression</value>
    <comment>This is a literal used when composing ParserError_* messages. Most blocks are named by the keyword that starts them, for example "if".  However, for those without keywords, a (localizable) name must be used.  This literal is ALWAYS used mid-sentence, thus should not be capitalized.</comment>
  </data>
  <data name="Cannot_Call_EndSpan_From_Temporary_Buffer" xml:space="preserve">
    <value>Temporary buffers must be accepted or rejected before "EndSpan" is called.</value>
  </data>
  <data name="DoNotBacktrack_Must_Be_Called_Within_Lookahead" xml:space="preserve">
    <value>The "DoNotBacktrack" method can be called only while in a look-ahead process started with the "BeginLookahead" method.</value>
  </data>
  <data name="EndBlock_Called_Without_Matching_StartBlock" xml:space="preserve">
    <value>"EndBlock" was called without a matching call to "StartBlock".</value>
  </data>
  <data name="No_Current_Parser_Block" xml:space="preserve">
    <value>Cannot render the span. There is no current block.</value>
    <comment>This error is seen by developers of custom parsers and code generators when they incorrectly call into our APIs</comment>
  </data>
  <data name="ParseDelimitedBlock_Requires_Bracket" xml:space="preserve">
    <value>The "ParseDelimitedBlock" method can only be used when the next non-whitespace character is guaranteed to be a bracket.</value>
  </data>
  <data name="ParseError_AtInCode_Must_Be_Followed_By_Colon_Paren_Or_Identifier_Start" xml:space="preserve">
    <value>The "@" character must be followed by a ":", "(", or a C# identifier.  If you intended to switch to markup, use an HTML start tag, for example:

@if(isLoggedIn) {
    &lt;p&gt;Hello, @user!&lt;/p&gt;
}</value>
  </data>
  <data name="ParseError_BlockComment_Not_Terminated" xml:space="preserve">
    <value>End of file was reached before the end of the block comment.  All comments started with "/*" sequence must be terminated with a matching "*/" sequence.</value>
  </data>
  <data name="ParseError_Expected_CloseBracket_Before_EOF" xml:space="preserve">
    <value>An opening "{0}" is missing the corresponding closing "{1}".</value>
  </data>
  <data name="ParseError_Expected_EndOfBlock_Before_EOF" xml:space="preserve">
    <value>The {0} block is missing a closing "{1}" character.  Make sure you have a matching "{1}" character for all the "{2}" characters within this block, and that none of the "{1}" characters are being interpreted as markup.</value>
  </data>
  <data name="ParseError_Expected_CloseParen_Before_EOF" xml:space="preserve">
    <value>A "(" is missing the corresponding ")".</value>
  </data>
  <data name="ParseError_Expected_X" xml:space="preserve">
    <value>Expected "{0}".</value>
  </data>
  <data name="ParseError_Expected_X__But_Got_Y" xml:space="preserve">
    <value>Expected "{0}" but encountered "{1}".</value>
  </data>
  <data name="ParseError_InfiniteLoopDetected" xml:space="preserve">
    <value>An internal error is causing the parser to enter an infinite loop at this location.

Current Parser State
  In Temporary Buffer: {0}
  Current Buffer Contents: [{1}]
  Current Location: {2}
  Current Character: {3}</value>
    <comment>Internal Error.  Users may see it but they aren't expected to do anything other than copy it into a bug report or forum post.</comment>
  </data>
  <data name="ParseError_InlineMarkup_Blocks_Cannot_Be_Nested" xml:space="preserve">
    <value>Inline markup blocks (@&lt;p&gt;Content&lt;/p&gt;) cannot be nested.  Only one level of inline markup is allowed.</value>
  </data>
  <data name="ParseError_Internal_Error_Is_Causing_Infinite_Loop" xml:space="preserve">
    <value>An internal parser error is causing an infinite loop at this location.</value>
    <comment>Users are not generally expected to see this, it is thrown as a result of failing a sanity check.</comment>
  </data>
  <data name="ParseError_MarkupBlock_Must_Start_With_Tag" xml:space="preserve">
    <value>Markup in a code block must start with a tag and all start tags must be matched with end tags.  Do not use unclosed tags like "&lt;br&gt;".  Instead use self-closing tags like "&lt;br/&gt;".</value>
  </data>
  <data name="ParseError_MissingEndTag" xml:space="preserve">
    <value>The "{0}" element was not closed.  All elements must be either self-closing or have a matching end tag.</value>
  </data>
  <data name="ParseError_MissingOpenBraceAfterSection" xml:space="preserve">
    <value>Sections cannot be empty.  The "@section" keyword must be followed by a block of markup surrounded by "{}".  For example:

@section Sidebar {
   &lt;!-- Markup and text goes here --&gt;
}</value>
  </data>
  <data name="ParseError_NamespaceImportAndTypeAlias_Cannot_Exist_Within_CodeBlock" xml:space="preserve">
    <value>Namespace imports and type aliases cannot be placed within code blocks.  They must immediately follow an "@" character in markup.  It is recommended that you put them at the top of the page, as in the following example:

@using System.Drawing;
@{
    // OK here to use types from System.Drawing in the page.
}</value>
  </data>
  <data name="ParseError_Sections_Cannot_Be_Nested" xml:space="preserve">
    <value>Section blocks ("{0}") cannot be nested.  Only one level of section blocks are allowed.</value>
    <comment>{0} is one of SectionExample_VB or SectionExample_CS based on the language.</comment>
  </data>
  <data name="ParseError_SingleLine_ControlFlowStatements_Not_Allowed" xml:space="preserve">
    <value>Expected a "{0}" but found a "{1}".  Block statements must be enclosed in "{{" and "}}".  You cannot use single-statement control-flow statements in CSHTML pages. For example, the following is not allowed:

@if(isLoggedIn)
    &lt;p&gt;Hello, @user&lt;/p&gt;

Instead, wrap the contents of the block in "{{}}":

@if(isLoggedIn) {{
    &lt;p&gt;Hello, @user&lt;/p&gt;
}}</value>
    <comment>{0} is only ever a single character</comment>
  </data>
  <data name="ParseError_Unexpected" xml:space="preserve">
    <value>Unexpected "{0}" after "{1}".</value>
  </data>
  <data name="ParseError_UnexpectedEndTag" xml:space="preserve">
    <value>Encountered end tag "{0}" with no matching start tag.  Are your start/end tags properly balanced?</value>
  </data>
  <data name="ParseError_Unexpected_Character_At_Section_Name_Start" xml:space="preserve">
    <value>Unexpected {0} after section keyword.  Section names must start with an "_" or alphabetic character, and the remaining characters must be either "_" or alphanumeric.</value>
  </data>
  <data name="ParseError_Unexpected_Character_At_Start_Of_CodeBlock_CS" xml:space="preserve">
    <value>"{0}" is not valid at the start of a code block.  Only identifiers, keywords, comments, "(" and "{{" are valid.</value>
    <comment>"{{" is an escape sequence for String.Format, when outputted to the user it will be displayed as "{"</comment>
  </data>
  <data name="ParseError_UnfinishedTag" xml:space="preserve">
    <value>End of file was reached before the "{0}" tag could be parsed.  Elements inside markup blocks must be complete. They must either be self-closing ("&lt;br /&gt;") or have matching end tags ("&lt;p&gt;Hello&lt;/p&gt;").  If you intended to display a "&lt;" character, use the "&amp;lt;" HTML entity.</value>
  </data>
  <data name="ParseError_Unterminated_String_Literal" xml:space="preserve">
    <value>Unterminated string literal.  Strings that start with a quotation mark (") must be terminated before the end of the line.  However, strings that start with @ and a quotation mark (@") can span multiple lines.</value>
  </data>
  <data name="Temporary_Buffers_Cannot_Be_Nested" xml:space="preserve">
    <value>Temporary buffers cannot be nested.</value>
  </data>
  <data name="Value_Must_Be_An_EnumType" xml:space="preserve">
    <value>Value must be an enumeration type.</value>
  </data>
  <data name="CodeGenerators_Must_Implement_Block_Or_StringProperty" xml:space="preserve">
    <value>Code generators must either implement {0} or {1}.</value>
  </data>
  <data name="ParseError_InvalidOptionValue" xml:space="preserve">
    <value>"{1}" is not a valid value for the "{0}" option. The "Option {0}" statement must be followed by either "On" or "Off". </value>
    <comment>{0} is either Strict or Explicit and represent VB's "Option Strict" and "Option Explicit" keywords</comment>
  </data>
  <data name="ParseError_UnknownOption" xml:space="preserve">
    <value>Unknown option: "{0}".</value>
  </data>
  <data name="ParseError_BlockNotTerminated" xml:space="preserve">
    <value>The "{0}" block was not terminated.  All "{0}" statements must be terminated with a matching "{1}".</value>
  </data>
  <data name="SectionExample_CS" xml:space="preserve">
    <value>@section Header { ... }</value>
    <comment>In CSHTML, the @section keyword is case-sensitive and lowercase (as with all C# keywords)</comment>
  </data>
  <data name="SectionExample_VB" xml:space="preserve">
    <value>@Section Header ... End Section</value>
    <comment>In VBHTML, the @Section keyword is case-insensitive (as with all VB keywords), but the standard practice is to Title Case it</comment>
  </data>
  <data name="ParseError_SlashInEmptyTagMustBeFollowedByCloseAngle" xml:space="preserve">
    <value>The "/" character in an empty tag, such as "&lt;text /&gt;", must be followed immediately by "&gt;".</value>
  </data>
  <data name="ParseError_TextTagCannotContainAttributes" xml:space="preserve">
    <value>"&lt;text&gt;" and "&lt;/text&gt;" tags cannot contain attributes.</value>
  </data>
  <data name="Structure_Member_Must_Be_NonNegative" xml:space="preserve">
    <value>The {0} property of the {1} structure must be 0 or greater.</value>
  </data>
  <data name="ParseError_NamespaceOrTypeAliasExpected" xml:space="preserve">
    <value>The "Imports" keyword must be followed by a namespace or a type alias on the same line.</value>
  </data>
  <data name="ParseError_Unexpected_WhiteSpace_At_Start_Of_CodeBlock_CS" xml:space="preserve">
    <value>A space or line break was encountered after the "@" character.  Only valid identifiers, keywords, comments, "(" and "{" are valid at the start of a code block and they must occur immediately following "@" with no space in between.</value>
  </data>
  <data name="ParseError_ExpectedCloseAngle_After_GenericTypeArgument" xml:space="preserve">
    <value>Expected '&gt;' after generic type argument.</value>
  </data>
  <data name="ParseError_ExpectedCloseParen_After_GenericTypeArgument" xml:space="preserve">
    <value>Expected ')' after generic type argument.</value>
  </data>
  <data name="ParseError_ExpectedOfKeyword_After_Start_Of_GenericTypeArgument" xml:space="preserve">
    <value>Generic type parameters in VB must be specified using the "Of" keyword. For example: System.Collections.Generic.List(Of System.String).</value>
  </data>
  <data name="ParseError_InheritsKeyword_Must_Be_Followed_By_TypeName" xml:space="preserve">
    <value>The 'inherits' keyword must be followed by a type name on the same line.</value>
  </data>
  <data name="ParseError_ExpectedTypeName_After_OfKeyword" xml:space="preserve">
    <value>Expected a type name after the "Of" keyword.</value>
  </data>
  <data name="ParseError_OuterTagMissingName" xml:space="preserve">
    <value>Outer tag is missing a name. The first character of a markup block must be an HTML tag with a valid name.</value>
  </data>
  <data name="Error_RecursiveCallToExecute" xml:space="preserve">
    <value>The Execute method cannot be called from within a CSHTML or VBHTML page body.</value>
  </data>
  <data name="ParseError_RazorComment_Not_Terminated" xml:space="preserve">
    <value>End of file was reached before the end of the block comment.  All comments that start with the "@*" sequence must be terminated with a matching "*@" sequence.</value>
  </data>
  <data name="ErrorComponent_Character" xml:space="preserve">
    <value>"{0}" character</value>
  </data>
  <data name="ErrorComponent_EndOfFile" xml:space="preserve">
    <value>end of file</value>
  </data>
  <data name="ErrorComponent_Whitespace" xml:space="preserve">
    <value>space or line break</value>
  </data>
  <data name="ParseError_Unexpected_Character_At_Start_Of_CodeBlock_VB" xml:space="preserve">
    <value>"{0}" is not valid at the start of a code block.  Only identifiers, keywords, comments, and "(" are valid.</value>
  </data>
  <data name="ParseError_Unexpected_EndOfFile_At_Start_Of_CodeBlock" xml:space="preserve">
    <value>End-of-file was found after the "@" character.  "@" must be followed by a valid code block.  If you want to output an "@", escape it using the sequence: "@@"</value>
  </data>
  <data name="ParseError_Unexpected_WhiteSpace_At_Start_Of_CodeBlock_VB" xml:space="preserve">
    <value>A space or line break was encountered after the "@" character.  Only valid identifiers, keywords, comments, and "(" are valid at the start of a code block and they must occur immediately following "@" with no space in between.</value>
  </data>
  <data name="Engine_UnableToLoadCodeDomProvider" xml:space="preserve">
    <value>Unable to load CodeDOM provider: {0}.</value>
  </data>
  <data name="CodeGenerator_SectionsNotSupported" xml:space="preserve">
    <value>Sections are not supported in this code generation environment.</value>
  </data>
  <data name="CodeGenerator_TemplatesNotSupported" xml:space="preserve">
    <value>Templates are not supported in this code generation environment.</value>
  </data>
  <data name="Structure_Member_CannotBeNull" xml:space="preserve">
    <value>The {0} property of the {1} structure cannot be null.</value>
  </data>
  <data name="ParseError_Unexpected_Character_At_Helper_Name_Start" xml:space="preserve">
    <value>Unexpected {0} after helper keyword.  All helpers must have a name which starts with an "_" or alphabetic character. The remaining characters must be either "_" or alphanumeric.</value>
  </data>
  <data name="ParseError_MissingCharAfterHelperParameters" xml:space="preserve">
    <value>Expected a "{0}" after the helper parameters.</value>
  </data>
  <data name="ParseError_MissingCharAfterHelperName" xml:space="preserve">
    <value>Expected a "{0}" after the helper name.</value>
  </data>
  <data name="ParseError_UnterminatedHelperParameterList" xml:space="preserve">
    <value>Helper parameter list is missing a closing ")".</value>
  </data>
  <data name="ParseError_Helpers_Cannot_Be_Nested" xml:space="preserve">
    <value>Helper blocks cannot be nested within each other.</value>
  </data>
  <data name="ParseError_Helpers_Cannot_Contain_Sections" xml:space="preserve">
    <value>Helper blocks cannot contain Sections.</value>
  </data>
  <data name="CodeWriter_MismatchedContexts" xml:space="preserve">
    <value>Mismatched writer contexts.  Attempted to end the "{0}" context, but the writer is currently in the "{1}" context.</value>
  </data>
  <data name="WriterContext_MethodCall" xml:space="preserve">
    <value>Method Invoke</value>
    <comment>This is a literal used when composing the CodeWriter_* messages.</comment>
  </data>
  <data name="CodeWriter_NoCurrentContext" xml:space="preserve">
    <value>Mismatched writer contexts.  Attempted to end the "{0}" context, but the writer is not currently in a context.</value>
  </data>
  <data name="WriterContext_LambdaDelegate" xml:space="preserve">
    <value>Delegate Lambda</value>
    <comment>This is a literal used when composing the CodeWriter_* messages.</comment>
  </data>
  <data name="WriterContext_Constructor" xml:space="preserve">
    <value>Constructor</value>
    <comment>This is a literal used when composing the CodeWriter_* messages.</comment>
  </data>
  <data name="WriterContext_LambdaExpression" xml:space="preserve">
    <value>Expression Lambda</value>
    <comment>This is a literal used when composing the CodeWriter_* messages.</comment>
  </data>
  <data name="ParserContext_VisitorStackEmpty" xml:space="preserve">
    <value>Visitor stack is empty.  Ensure all calls to PushVisitor have a matching PopVisitor call.</value>
  </data>
  <data name="Span_GetInserted_Must_Be_Called_With_Insertion" xml:space="preserve">
    <value>GetInserted must be called with an insertion change.</value>
  </data>
  <data name="Parser_Context_Not_Set" xml:space="preserve">
    <value>Parser was started with a null Context property.  The Context property must be set BEFORE calling any methods on the parser.</value>
  </data>
  <data name="ParseError_Unexpected_Keyword_After_At" xml:space="preserve">
    <value>Unexpected "{0}" keyword after "@" character.  Once inside code, you do not need to prefix constructs like "{0}" with "@".</value>
  </data>
  <data name="ParseError_ReservedWord" xml:space="preserve">
    <value>"{0}" is a reserved word and cannot be used in implicit expressions.  An explicit expression ("@()") must be used.</value>
  </data>
</root>